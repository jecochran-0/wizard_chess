1. Project Setup and Code Standards
   Initialize React Project: Create a new React application (using Create React App or Vite) named WizardChess. Choose JavaScript or TypeScript based on the design document preference. Once created, run the development server to ensure the base app works.
   Test: Start the app (e.g., npm start or npm run dev) and verify the default React welcome page loads in the browser.
   Set Up Version Control: Initialize a Git repository in the project folder. Commit the freshly created project as the initial commit. This will help track changes as you progress.
   Test: Run git status to ensure all files are committed and the working directory is clean.
   Install Required Libraries: Add the key dependencies needed for the project:
   – Chess.js (for game logic)
   – GSAP (for animations)
   – Stockfish (for AI, possibly via an NPM package or including a web worker file)
   – Socket.IO Client (for real-time multiplayer)
   – Firebase (for authentication and database)
   Use npm install or yarn add to install these.
   Test: Check package.json to confirm all libraries are listed. Import each library in a test file (or App.js) and run the app to ensure there are no import errors.
   Apply Coding Standards Setup: Incorporate the provided coding standards and style rules into the project. For example, add an ESLint configuration (using the rule set given, such as Airbnb style or custom rules) and a Prettier config if provided. Ensure rules like using functional components only and consistent naming conventions are enforced.
   Test: Create a small intentional style violation (e.g., a unused variable or a console log if disallowed) and run the linter (npm run lint). Verify that the linter catches the issue. Fix the issue and ensure npm run lint passes without errors.
   Folder Structure and Modularity: Set up a logical project structure to keep code modular. Create directories such as src/components for React components, src/hooks for custom hooks, src/services for Socket and Firebase logic, and src/utils for utility functions (like any helpers for chess moves). This will align with the modularity guidelines from the design doc.
   Test: Ensure the created folders are in place and adjust import paths if needed. No functionality to test yet, but confirming the structure now will make further development easier.
2. UI Components – Board and Pieces
   Create Chessboard Component: In src/components, create a functional component Board that renders an 8x8 chess board. Use a two-dimensional array or loop to generate 8 rows and 8 columns. Each square can be a simple <div> with a class for styling (alternating light and dark colors). Adhere to coding style (e.g., Board in PascalCase, no logic outside the component).
   Test: Import and render <Board /> in App.js. In the browser, verify that an 8x8 grid of squares is displayed with alternating colors, confirming the board layout is correct.
   Create Square/Piece Components: Build a Square component (functional) that represents a single cell on the chessboard. It should accept props such as position (like "e4") or coordinates and possibly a piece to display. Also create a Piece component to render a chess piece (this could simply return an image or unicode character for the piece, based on type and color props). Keep these components small and reusable, following the style rules (e.g., one component per file, proper prop naming).
   Test: Modify the Board component to use <Square> for each cell. Pass a sample piece prop to a couple of Square components (for example, place a rook at A1, etc.) using <Piece> inside. Run the app and confirm that those squares show a piece icon or text while others are empty.
   Apply Basic Styling: Use CSS (or a CSS-in-JS approach, as per project guidelines) to size the board and pieces. Ensure each square is equal size and pieces are visually centered within squares. This may involve adding a CSS file for the board or using styled-components if specified by the standards. Keep styles consistent (e.g., use variables or consistent units) as per the style guide.
   Test: Open the app and verify the board appears with proper dimensions (8x8 grid filling the intended area) and that piece graphics or text are visible and properly centered. Resize the browser to ensure the board scales or remains correctly proportioned if responsiveness is required by design.
   Render Initial Chess Setup: Prepare the initial chess position on the board. You can use a constant or utilize Chess.js to get the initial setup. For now, manually place all pieces in their starting squares by passing the appropriate piece props to each Square (e.g., Rooks at a1/h1, Knights at b1/g1, etc., for white and similarly for black on rank 8). This static setup will be replaced by dynamic state later, but it's good for initial visual confirmation.
   Test: Confirm in the browser that the board now shows all 32 chess pieces in the correct starting positions. Compare with a standard chess starting layout to ensure accuracy.
3. Game State Management with Chess.js
   Integrate Chess.js Library: Import the Chess.js library into the project (for example, in a new file src/utils/chessGame.js or within a context/hook). Initialize a Chess instance (e.g., const game = new Chess()) to manage the game state. Decide where to store this instance: a React context or a custom hook is ideal so that multiple components can access game state if needed. Following modularity rules, avoid putting game logic directly in UI components.
   Test: Log the initial game state or moves from the Chess instance to ensure it's working. For example, in App.js or a context, do console.log(game.fen()) or game.moves() and check the console in the browser for a valid output (FEN string or list of moves).
   Connect Board to Chess State: Refactor the Board component to use Chess.js for the pieces layout instead of the hardcoded initial placement. For instance, retrieve the board array from Chess.js (game.board() returns a 2D array of pieces) and use that to render pieces dynamically. Maintain this data in React state (e.g., useState for current board positions or store the Chess instance in state). Ensure using hooks correctly as per standards (e.g., useState for triggering re-renders, useEffect if needed to initialize).
   Test: After this change, the board should still display the initial setup. To verify Chess.js is truly in control, move a piece via a Chess.js call (temporarily, in a dev test button or in console, do something like game.move('e2e4') and update the state) and confirm the board re-renders that pawn in the new location (e4) and the old spot is empty.
   Implement Move Execution with Chess.js: Set up a function to handle moves using Chess.js. When a player attempts to move a piece (we'll implement the UI for this next), this function will call game.move({ from: <square>, to: <square>, promotion: <piece> }) on the Chess instance. It should update the game state and return whether the move was successful. Integrate this with state so that a successful move triggers a re-render of the board with updated piece positions.
   Test: For now, simulate calling this move function manually (e.g., hardcode a call to move a pawn or use the browser console). Verify that the function returns the move details on a valid move and that the board updates accordingly. Also try an illegal move (like moving a pawn from e2 to e5 in one go) and confirm that Chess.js rejects it (the board should not change).
   Game Over Detection: Utilize Chess.js functions to detect game termination conditions. After each move, check game.game_over(), or more specifically game.in_checkmate() / game.in_stalemate() / game.in_draw(). If the game has ended, handle it by showing an alert or UI message indicating the result (e.g., "Checkmate! White wins."). Following coding standards, put this logic in the game state manager (not in the UI component directly) if possible.
   Test: You can force a nearly endgame state (using Chess.js moves to set up a checkmate scenario) or play through a quick checkmate. When a checkmate occurs, verify that the game over condition is detected and the message appears. Ensure that further moves are prevented once the game is over.
4. Piece Movement and User Interaction
   Enable Piece Selection: Add interactivity to the chessboard. Implement an onClick handler on the Square or Piece components so that when a piece is clicked, the application knows this is the piece to move. Store the selected piece/square in state (e.g., selectedSquare). For visual feedback, highlight the selected square and possibly highlight the legal moves for that piece (you can get legal moves via game.moves({ square: selectedSquare }) from Chess.js). Keep the highlight implementation simple and within style guidelines (perhaps conditional CSS class).
   Test: Click on a piece in the browser. Check that the internal state for selectedSquare is set (you might log it or display it in some debug UI). Also verify that the clicked square gets a highlight style (e.g., a border or background change). If implementing move highlights, confirm that the correct target squares are highlighted for that piece.
   Implement Move on Second Click: Allow the player to complete a move by clicking a destination square after selecting a piece. If a selectedSquare is already set and the player clicks a different square, treat that as the intended move. Call the Chess.js move function with the from/to coordinates. If the move is valid (the function returns a move object), update the board state. If invalid (function returns null), you can ignore it or display an error, then clear the selection. After a successful move, clear the selection and prepare for the next turn.
   Test: Select a piece and then click a valid destination. The piece should move to the new square on the board. Try selecting a piece and clicking an invalid square (e.g., move a knight like a bishop); the piece should remain in place (Chess.js will reject the move). Also test capturing: select a piece and click a square occupied by an opponent's piece (set one up manually to test) to ensure the capture is processed (the opponent's piece should disappear).
   Drag-and-Drop (Optional Enhancement): If the design requires drag-and-drop interaction instead of click-click, integrate a drag-and-drop library or React DnD to allow dragging pieces to a square. This would involve making Piece draggable and Square droppable, then on drop event, determining the from/to and calling the Chess.js move. This step is optional and should be done only if specified, as click-based movement is sufficient for core functionality.
   Test: (If implemented) Drag a piece to a new square and release. Verify the piece moves to that square. Try dragging to an illegal square and ensure it snaps back or the move is not accepted.
   Validate Turns and Turns Indicator: Use Chess.js or your own state to track whose turn it is (white or black). Disable the ability to move the wrong color piece on a given turn. For example, if it's white's turn, clicking a black piece should either do nothing or show a message. After a successful move, switch the turn indicator. Add a UI element to show current turn (e.g., "White's turn" or "Black's turn").
   Test: Try to move black's piece when it's white's turn (nothing should happen). Make a valid white move, then attempt another white move immediately (should be prevented until black moves, unless single-player which will be handled later). Ensure the turn display updates after each move.
5. Animations with GSAP
   Install and Import GSAP: Verify GSAP is installed (if not, install it now). Import GSAP into the project (for example, in the Board or Piece component file). You may also use GSAP's timeline features if complex animations are needed. Ensure this doesn’t conflict with React (it usually doesn't, but follow any best practices from docs, e.g., using refs to DOM elements).
   Test: As a quick test, use GSAP to animate a dummy element. For instance, add a temporary button or piece of text in a component and on a button click, use gsap.to(elementRef, { x: 100 }) to move it. Click the button and confirm the animation works, indicating GSAP is set up correctly.
   Animate Piece Movement: Integrate GSAP animations when moving pieces. Instead of an instantaneous re-render jump, animate the piece from its old square to the new square. You can achieve this by absolutely positioning the moving piece's element and tweening its x,y coordinates to the destination, or by using a GSAP plugin if available. Consider using a ref for each piece/square to target the DOM node. When a move is made, before updating state, play an animation moving the piece's image from source to target, then on completion of animation update the React state to finalize the piece's new position.
   Test: Move a piece on the board. Visually confirm that the piece glides to the new position instead of teleporting. The movement should be smooth. Try moves in different directions (vertical, horizontal, diagonal) to ensure the animation calculation is correct for all.
   Animate Captures: When a piece is captured, add an animation for it as well. For example, fade out the captured piece or animate it sinking/vanishing before the moving piece occupies the square. You could also animate the moving piece over the captured piece (perhaps a brief shake or scale effect to simulate an impact). Use GSAP sequences or timelines to coordinate these (first remove captured piece, then move the attacker).
   Test: Perform a capture move. The enemy piece should visibly disappear with the chosen effect, and the moving piece should end up in that square with a smooth transition. Ensure the captured piece is removed from the React state after animation so it doesn’t reappear on re-render.
   Adjust Animation Timing and Easing: Fine-tune the animation speed and easing (perhaps a quick ease-out for movement, a slight delay for dramatic effect on capture). Ensure the animation duration is reasonable so as not to frustrate fast players. These values might be guided by the design document (Wizard’s Chess might have somewhat dramatic but not too slow animations).
   Test: Try a sequence of moves in succession. Confirm that one move's animation finishes before the next begins (to avoid overlapping issues). If a user tries to move another piece before animation finishes, decide if input is locked or the move queues – test that the game doesn’t break if moves are made quickly.
   Maintain State Sync: Make sure the GSAP animations do not desynchronize the game state. The Chess.js state should already be updated when the move is initiated; the animation is just visual. To be safe, you might update the state only after animation completes (or immediately update state and rely on the piece component to still show the moving piece until animation ends). This detail can be handled with a combination of React state and GSAP onComplete callbacks.
   Test: After an animated move, double-check that the internal Chess.js state and the rendered board state are consistent (the piece really moved). Perform a game-over scenario (like a checkmate move) and ensure the animation plays and then the game-over logic still triggers correctly.
6. Single-Player Mode with Stockfish AI
   Add Stockfish Engine: Integrate the Stockfish chess engine for AI moves. Include it via an NPM package (like stockfish which provides a Web Worker) or by adding the Stockfish JS file to the public folder and creating a worker manually. Follow the design doc's approach (some provide a ready wrapper). Initialize the Stockfish engine in a web worker when the app starts or when single-player mode begins.
   Test: Verify that the Stockfish engine is loaded by sending a basic UCI command. For example, post "uci" to the worker and listen for a response in the console (the engine should reply with identification info). This ensures the AI engine is running.
   Create AI Move Handler: Develop a function to handle AI moves after the human player moves. When in single-player mode (you can set a state like isSinglePlayer = true when starting that mode), and it’s black’s turn (assuming human is white for simplicity, or allow choice), send the current game state to Stockfish. Typically, you send the FEN or the moves history: e.g., stockfish.postMessage('position fen ' + game.fen()), then stockfish.postMessage('go depth 15') to have it calculate a move. Listen for the engine's response message containing the best move (in UCI format like "e7e5").
   Test: After making a move as white, check that a message is sent to Stockfish and that after a moment, the engine responds with a move. Log the move response to ensure you receive something like "bestmove e7e5".
   Apply AI Move to Game: Parse the Stockfish best move response and execute it on the Chess.js game. The move will be in algebraic or UCI notation (e.g., "e7e5"); use Chess.js game.move() with the from/to squares from that string. Then update the state just as with a human move, and trigger the GSAP animation for the AI's piece movement. Ensure this is done after the engine returns the move.
   Test: When playing as white in single-player, make a move (e.g., e2 to e4). After a short delay, observe black's corresponding piece move (e.g., pawn from e7 to e5) on the board. The move should animate and the board state update correctly with no intervention.
   Balance AI Difficulty (if applicable): Optionally, configure Stockfish level or depth according to desired difficulty. Stockfish can be very strong; for a more casual game, limit depth or use an easier level setting if available. This might be done via sending setoption name Skill Level value <n> or adjusting depth/time for search.
   Test: If you adjust difficulty, play a few moves and verify the AI isn't too fast or making only perfect moves (depending on requirements). This is more of a tuning step, so ensure the game remains responsive and fun.
   Single-Player Game Flow: Implement UI controls to start a single-player game vs AI. For instance, on the home screen or menu, provide an option "Play vs Computer". When clicked, reset the Chess.js game to initial state, ensure isSinglePlayer mode is true, and perhaps allow choosing color (if user chooses black, you'd have AI play white first move, etc.). Also, disable the AI move handler when not in single-player mode (so Stockfish isn't running during PvP games).
   Test: Navigate through the app to start a single-player game. Ensure the board resets to start and the user can move. If the user is set as black, verify the AI immediately makes a move as white to start the game. Play through a full game if possible to ensure the AI responds each turn and the game can reach completion (checkmate or draw).
7. Real-Time Multiplayer with Socket.IO
   Set Up Socket.IO Server: Create a simple Node.js server (in a separate folder or repository, as per design doc architecture) that uses Socket.IO. The server will facilitate real-time multiplayer games. Implement basic server logic: when a client connects, allow them to join a "room" or match. The server should handle events like "moveMade" by one client and broadcast it to the opponent in the same room. Keep the server code modular (perhaps a separate file for socket event handlers).
   Test: Run the Socket.IO server locally (e.g., node server.js). Open two browser windows (or tabs) for the React app (which we'll connect next) and ensure the server logs show connections from both when they join a game.
   Integrate Socket.IO Client in React: In the React app, install the socket.io-client package. Create a service or context (e.g., src/services/socketService.js) to manage the socket connection. When a player chooses multiplayer mode (e.g., clicks "Play Online"), connect to the Socket.IO server (provide the server URL). Upon connecting, emit an event to either create or join a game room. You might implement a simple matchmaking: if a game ID is needed, allow input or generate one.
   Test: From the React app, trigger the connection (maybe a "Join Game" button). Verify the server logs the new connection and that the client side shows a successful connection (could console log an "connected" message on connect). If using rooms, ensure that two clients join the same room (perhaps using a known room ID for testing).
   Multiplayer Turn Management: Decide how to synchronize turns between two players. One approach: designate the first connected player as white and second as black. The server can emit a message to each client about their color or role. The clients should then enforce turn order based on their color (only allow moves if it’s their turn). The server should also validate moves using its own Chess.js instance to prevent illegal moves or cheating.
   Test: After both clients are connected and colors assigned, attempt a move from the white client when it’s white’s turn – it should go through. Try a move from the black client out-of-turn (before white moves) – it should be ignored or get rejected by server validation.
   Send and Receive Moves: When a player makes a move on their board (using the earlier Chess.js logic), instead of (or in addition to) directly updating the local state, emit a Socket.IO event like "moveMade" with the move details (e.g., the from/to squares or algebraic notation). The server receives this, updates its game state, and broadcasts the move to the opponent. The opponent's client receives the move event and applies it to their local Chess.js state and board (with animation).
   Test: Make a move as White in one browser. Observe in the other browser that the piece moves accordingly. Check the server logs or state to confirm it processed the move. Then make a move as Black from the second browser and verify it shows up in the first. Ensure both boards remain in sync through multiple moves.
   Handle Game Over and Disconnects: Implement handling for game end in multiplayer. If a checkmate or draw occurs, the server can broadcast a "gameOver" event with the result, or clients can detect it via their Chess.js (but server authoritative is better to prevent disputes). Display a game over message to both players. Also handle if a player disconnects mid-game: the server should inform the remaining player and possibly mark the game as aborted or a win by forfeit.
   Test: Simulate a game to completion (or artificially force a checkmate in code for speed). Verify both clients receive the game over notice. Then simulate a disconnect: close one client's tab and ensure the other client is notified (maybe show "Opponent left the game").
   Multiplayer UI and Lobby: Create a simple UI flow for multiplayer: e.g., a menu to either create a game (generate a room code and wait for opponent) or join a game (enter code). Use Socket.IO events to facilitate this (server can create a room on request and return the code, etc.). Keep this UI intuitive and handle errors (like invalid room code or opponent not showing up).
   Test: Go through the UI: create a game in one browser (note the code), join that code from another browser. Ensure both reach the chess board and can start playing. Try an invalid code to see an error message. This confirms the end-to-end multiplayer setup is working.
8. Firebase Authentication
   Set Up Firebase Project: Create a Firebase project in the Firebase console if not done already. Enable the desired authentication methods (Email/Password and/or others like Google OAuth per design spec). In the React app, install Firebase SDK (firebase npm package) and add the configuration object (apiKey, authDomain, etc.) to initialize Firebase (usually in a firebase.js or in an environment file as per security practices).
   Test: Run the app and ensure there are no Firebase initialization errors. No user yet, but the config should be correctly set (you can verify by calling firebase.apps.length in console and seeing that an app is initialized).
   Implement Sign Up & Login UI: Create components for Login and Register (or a combined AuthForm) in src/components. These should use controlled inputs for email and password, and call Firebase Auth functions on submit. Use functional components with hooks (e.g., useState for form values). Keep forms simple and follow any style guidelines (for example, form validation rules if provided).
   Test: Render the Login/Registration component in the app (temporarily or via a route). Manually input an email and password and submit to create a new account (using createUserWithEmailAndPassword). Check the browser console or network to ensure no errors, and verify in the Firebase console that the new user appears under Authentication.
   Handle Auth State: Use Firebase Auth to track the logged-in user state. Implement an Auth Context or use onAuthStateChanged listener in a top-level component (e.g., in App or a dedicated AuthProvider component) to respond to login/logout. Store the user (maybe just uid, email) in a context or global state so that the rest of the app knows if a user is logged in.
   Test: After signing up or logging in, ensure the app state recognizes the user (e.g., context has the user object, maybe display the user's email in a header as feedback). Also test logging out (use signOut from Firebase) and verify the state resets (user becomes null) and UI updates accordingly.
   Protect Routes / Conditional Rendering: If your app has multiple pages (like a menu, game screen, history screen), implement route protection or conditional rendering based on auth. For example, if a user is not logged in, show the Login component or prevent access to the game board except maybe a demo. Use React Router if routing is needed (or simple conditionals if it's single-page with modals). Ensure this logic is clear and follows coding standards (separation of concerns: perhaps a PrivateRoute component).
   Test: Try accessing the game without logging in (if possible) and ensure the app redirects to login or shows a message. Log in and ensure you can then access the game features. This confirms auth gating works.
   Feedback and Error Handling: Implement basic error handling for auth (e.g., show messages for wrong password, email already in use, etc., using Firebase error codes). Also give feedback while requests are in progress (like a loading spinner or disabling the submit button).
   Test: Attempt to log in with an incorrect password for a test user. Verify an error message appears. Try signing up with an already-used email and ensure the error is shown. This improves the user experience around auth.
9. Firebase Firestore – Game History
   Setup Firestore Database: In Firebase console, enable Cloud Firestore. In the React project, initialize Firestore via Firebase (e.g., import { getFirestore } from "firebase/firestore" and configure as needed). Decide on a data model for game history: for example, a collection games where each document contains fields like playerWhite, playerBlack, moves (could be an array of moves or a PGN string), result, timestamp. If multiple users can save history, include user IDs in the data for query filtering.
   Test: Write a test document to Firestore using the Firebase SDK in a controlled way (maybe call a function on a button click to add a dummy game record). Then check the Firebase console to ensure the document was created in the games collection.
   Save Game Result: When a game ends (from earlier game-over detection logic), prepare the data to save. Gather the players' identifiers (for single-player, player and "AI" or just note AI as opponent; for multiplayer, both users' UIDs or names; for local play, maybe just one user if logged in, or skip saving if no user). Also gather the move history: Chess.js can provide a PGN or list of moves (game.pgn() or the history array). Then use Firestore to add a new document with this info. Only do this if a user is logged in (per design, game history might be tied to user accounts).
   Test: Finish a game in any mode while logged in. After the game over, check the Firebase console for a new game record. Verify the fields (players, result, moves) are correctly saved. If possible, trigger both a single-player game save and a multiplayer game save to ensure both scenarios are handled.
   Retrieve and Display History: Create a History component or page that fetches the logged-in user's past games from Firestore. Use a Firestore query to get games where the current user is a participant (match user UID to playerWhite or playerBlack). Order by timestamp to show recent games first. Display this list in a table or list format, showing basics (date, opponent, result). Optionally, allow clicking a game to see more details or even replay it if that's a desired feature (though replay might be advanced).
   Test: Log in as a user who has some game records. Navigate to the History page. Verify that a list of games is shown. Each entry should correctly reflect the saved data (for example, "Win vs AI on 2025-03-24", "Loss vs [opponent name] on ..."). If no games, the page should handle that gracefully (e.g., "No games played yet").
   Secure Data Access: Although not directly a coding step in the app, ensure your Firebase security rules restrict game records so that only authorized users can read their own history and write new records. This might involve writing Firestore rules to allow create if the user matches a field in the document, etc. Write these rules according to the design's security requirements.
   Test: Use the Firebase rules simulator or attempt to access another user's game document by modifying the query (if possible) to ensure the rules prevent it. All legitimate use cases should still succeed (e.g., the user can fetch their own games).
   Optimize and Cleanup Data: (Optional) If games produce a lot of move data, consider cleaning the stored moves (maybe storing as a compact PGN string instead of array). Also, if using Realtime Database instead, adjust steps accordingly. This is more of a consideration than a step, and should be done if the design emphasizes performance.
   Test: Not a specific test here, but ensure that storing and loading game history is quick (for example, test with several dozens of games to see if the UI remains responsive).
10. Code Modularity and Final Review
    Refactor into Modular Components: Review the codebase and ensure that each component and module has a single responsibility and is not too large. For example, if the Board component is handling too many concerns, refactor out a separate GameController or context. Ensure all React components remain functional (no class components) and use hooks for state and side effects as per standards.
    Test: The application should still run exactly as before after refactoring. Run through a quick game to confirm nothing was broken during the reorganization.
    Consistency with Coding Standards: Go through the code with the provided style guide in mind. Check for naming conventions (are variables and functions named clearly and consistently? e.g., use camelCase for functions, PascalCase for components), formatting issues, and removal of any lingering console logs or commented-out code. Ensure the code is well-documented if the standards call for it (for instance, JSDoc comments for functions or at least comments for complex sections).
    Test: Run the linter one more time (npm run lint) to catch any stray issues. The linter output should be clean. Optionally, have a colleague or use a code review tool to do a quick scan for any style deviations.
    Final End-to-End Testing: Perform an end-to-end test of all features together to ensure they work in harmony:
    – Start the app, log in with a test user.
    – Play a game vs AI fully to a finish, and check that the history is saved.
    – Start a multiplayer game with another test user (you may need to build the app and serve it twice or use incognito for second user). Play a few moves and ensure both clients sync and the game can be completed.
    – Try any edge cases like resigning (if you added a resign button) or refreshing mid-game to see how the app recovers (maybe your design persists game state or not).
    Test: Verify each mode and feature behaves as expected: animations play, rules enforced, AI responds, moves sync online, auth gates access, and history records properly. This final check ensures the project meets the full scope and quality standards.
